gs.spkr = gs.speakers$speaker,
your.spkr = ""
)
tier.equiv.temp$your.spkr[which(
tier.equiv.temp$gs.spkr == "CHI")] <- "CHI"
nonchi.gs.s.p <- gs.tier.perms[perm,]
nonchi.nw.s.p <- nonchi.nw.s
length(nonchi.gs.s.p) > 0
gs.tier.tomatch <- nonchi.gs.s.p[1]
nonchi.gs.s.p <- nonchi.gs.s.p[!nonchi.gs.s.p %in% gs.tier.tomatch]
# Find the slice_match value between the chosen GS tier and every NW option
nonchi.nw.s.p <- sample(nonchi.nw.s.p) # randomize the NW tiers
best.nw.match <- "<no match>"
best.slice.score <- 0
length(nonchi.nw.s.p) > 0
tier.opt <- nonchi.nw.s.p[1]
tier.opt
nonchi.nw.s.p
View(intersect.spk.tiers(gs.file, nw.file,
gs.tier.tomatch, tier.opt,
seg_stt, seg_end,
strict, slice_sz))
strict
annA <- gs.file
annB <- nw.file
tierA <- gs.tier.tomatch
tierB <- tier.opt
seg_stt
seg_end
strict
slice_sz
segA <- annA %>%
filter(tier == tierA & stop > seg_stt & start < seg_end) %>%
mutate(coder = "A")
segB <- annB %>%
filter(tier == tierB & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
segAB.spch <- bind_rows(segA, segB)
up
segAB.spch
gs.tier.tomatch
tier.opt
tier.opt <- "FA1"
tierB <- tier.opt
segB <- annB %>%
filter(tier == tierB & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
segA
segB
segAB.spch <- bind_rows(segA, segB)
segAB.spch
ABtbl <- tibble(
slice = seq(seg_stt, seg_end + slice_sz, slice_sz),
spchA = 0,
spchB = 0)
ABtbl
nrow(segAB.spch) > 0
nrow(segAB.spch)
row <- 1
startannot <- ifelse(segAB.spch$start[row] < seg_stt, seg_stt,
segAB.spch$start[row])
stopannot <- ifelse(segAB.spch$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.spch$stop[row])
startannot
stopannot
segAB.spch$coder[row] == "A"
gs.tiers.temp$tier
tiertype <- "xds@FA1"
tierspkr <- tiertype
(grepl("@", tiertype))
tierspkr <- substr(tiertype, 5, 7)
tiertype
tierspkr
annA <- gs.file
annB <- nw.file
strict
tiertype
seg_stt
seg_end
slice_sz
grepl("@", tiertype)
spkr <- substr(tiertype, 5, 7)
ttyp <- substr(tiertype, 1, 3)
spkr
ttyp
segA <- annA %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "A")
segB <- annB %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
segAB.spch <- bind_rows(segA, segB) %>% filter(tier == spkr)
segAB.dpdt <- bind_rows(segA, segB) %>% filter(tier == tiertype)
segAB.spch
segAB.dpdt
ttyp
ABtbl <- tibble(
slice = seq(seg_stt, seg_end - slice_sz, slice_sz),
spchA = 0,
spchB = 0,
valA = "NA",
valB = "NA")
ABtbl
if(nrow(segAB.spch) > 0) {
for (row in 1:nrow(segAB.spch)) {
startannot <- ifelse(segAB.spch$start[row] < seg_stt, seg_stt,
segAB.spch$start[row])
stopannot <- ifelse(segAB.spch$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.spch$stop[row])
if (segAB.spch$coder[row] == "A") {
ABtbl$spchA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
} else {
ABtbl$spchB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
}
}
}
ttyp != "ort"
nrow(segAB.dpdt)
segAB.dpdt
row <- 1
for (row in 1:nrow(segAB.dpdt)) {
startannot <- ifelse(segAB.dpdt$start[row] < seg_stt, seg_stt,
segAB.dpdt$start[row])
stopannot <- ifelse(segAB.dpdt$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.dpdt$stop[row])
valannot <- segAB.dpdt$code[row]
if (segAB.dpdt$coder[row] == "A") {
ABtbl$valA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
} else {
ABtbl$valB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
}
}
ABtbl
ABtbl <- ABtbl %>%
filter(spchA == 1 & spchB == 1)
ABtbl
ttyp
xds.loose.matches <- tibble(
GS = c(C, C, B, B, B, A, A, P, P, P, O, O, O, U, O, U),
NW = c(C, B, B, C, A, A, B, P, O, U, O, P, U, P, O, U)
)
xds.loose.matches <- tibble(
GS = c('C', 'C', 'B', 'B', 'B', 'A', 'A', 'P', 'P', 'P', 'O', 'O', 'O', 'U', 'O', 'U'),
NW = c('C', 'B', 'B', 'C', 'A', 'A', 'B', 'P', 'O', 'U', 'O', 'P', 'U', 'P', 'O', 'U')
)
xds.loose.matches
paste0(ABtbl$valA, ABtbl$valA)
ABtbl
View(ABtbl)
ABtbl$match <- ifelse(paste0(ABtbl$valA, ABtbl$valA) %in%
paste0(xds.loose.matches$GS, xds.loose.matches$NW), 1, 0)
ABtbl <- filter(ABtbl, valA != 'U')
ABtble <- mutate(tier = tiertype) %>%
select(-spchA, -spchB)
ABtbl <- mutate(tier = tiertype) %>%
select(-spchA, -spchB)
ABtbl <- ABtbl %>%
mutate(tier = tiertype) %>%
select(-spchA, -spchB)
nw.filename <- "5959-0GS0-lctest.txt"
# Input files
nw.file <- read.annot(nw.filename)
nw.file$code[which(is.na(nw.file$code))] <- "<empty>"
gs.file <- read.annot(paste0(recording, "-0GS0.txt"))
ntvness <- ifelse(native == "Yes", "native", "NON-native")
compare.stmt <- paste0("Comparing minute ", minute, " of recording ",
recording, " to the gold standard.")
coder.stmt <- paste0("Submitted by coder ", coder, " from the ", lab,
" lab, who is a ", ntvness,
" speaker of the language in the recording.")
# Input arguments
slice_sz <- 50 # size of time slices compared
strict <- ifelse(evaltype == "Normal", 1, 0)
if (strict == 1) {
min_overall_score <- 0.95 # minimum overall weighted score
min_score_univ <- 0.85 # minumum score allowed on diarization and vcm
if (native == "Yes") {
min_score_lgsp <- 0.85 # minumum score allowed on lex, mwu, and xds
} else {
min_score_lgsp <- 0.75 # minumum score allowed on lex, mwu, and xds
}
} else {
min_overall_score <- 0.8 # minimum overall weighted score
min_score_univ <- 0.8 # minumum score allowed on diarization and vcm
if (native == "Yes") {
min_score_lgsp <- 0.85 # minumum score allowed on lex, mwu, and xds
} else {
min_score_lgsp <- 0.75 # minumum score allowed on lex, mwu, and xds
}
}
################################################################################
# Run comparison
################################################################################
# Determine the onset and offset times of the segment to be compared
# if minute is NA then the whole file is compared
seg_stt <- (minute-1)*60000
seg_end <- minute*60000
# Match up the nw file tiers to the gold standard as closely as possible
gs.speakers <- gs.file %>%
filter(stop > seg_stt & start < seg_end & !is.na(speaker)) %>%
distinct(speaker)
nw.speakers <- nw.file %>%
filter(stop > seg_stt & start < seg_end & !is.na(speaker)) %>%
distinct(speaker)
# Create a tier equivalence table: match based on speech on/off similarity
tier.equiv <- tibble(
gs.spkr = gs.speakers$speaker,
your.spkr = ""
)
gs.tiers <- gs.file %>%
filter(stop > seg_stt & start < seg_end & (!is.na(speaker))) %>%
select(tier, speaker) %>% distinct() %>% arrange(speaker) %>%
mutate(slice_match = "", n_annots = "", sec_annots = "",
slice_match_n = 0, nsec_spch = 0)
errors.tbl <- tibble()
# CHI is always matched with CHI
tier.equiv$your.spkr[which(tier.equiv$gs.spkr == "CHI")] <- "CHI"
# The others are matched as a set...
nonchi.gs.s <- subset(gs.speakers, speaker != "CHI")$speaker
nonchi.nw.s <- subset(nw.speakers, speaker != "CHI")$speaker
gs.tier.perms <- permutations(n=length(nonchi.gs.s), r=length(nonchi.gs.s),
v=nonchi.gs.s,repeats.allowed=F)
# For each permutation of the non-CHI speakers in the GS,
# find the best set of non-CHI speakers in the coder's file
top.score <- 0
gs.tier.perms
perm <- 1
tier.equiv.temp <- tibble(
gs.spkr = gs.speakers$speaker,
your.spkr = ""
)
tier.equiv.temp$your.spkr[which(
tier.equiv.temp$gs.spkr == "CHI")] <- "CHI"
nonchi.gs.s.p <- gs.tier.perms[perm,]
nonchi.nw.s.p <- nonchi.nw.s
while (length(nonchi.gs.s.p) > 0) {
gs.tier.tomatch <- nonchi.gs.s.p[1]
nonchi.gs.s.p <- nonchi.gs.s.p[!nonchi.gs.s.p %in% gs.tier.tomatch]
# Find the slice_match value between the chosen GS tier and every NW option
nonchi.nw.s.p <- sample(nonchi.nw.s.p) # randomize the NW tiers
best.nw.match <- "<no match>"
best.slice.score <- 0
if (length(nonchi.nw.s.p) > 0) {
for (tier.opt in nonchi.nw.s.p) {
match.mean <- mean(intersect.spk.tiers(gs.file, nw.file,
gs.tier.tomatch, tier.opt,
seg_stt, seg_end,
strict, slice_sz)$match)
if (match.mean > best.slice.score) {
best.slice.score <- match.mean
best.nw.match <- tier.opt
}
}
}
tier.equiv.temp$your.spkr[which(
tier.equiv.temp$gs.spkr == gs.tier.tomatch)] <- best.nw.match
nonchi.nw.s.p <- nonchi.nw.s.p[!nonchi.nw.s.p %in% best.nw.match]
}
tier.equiv.temp
nw.file.temp <- nw.file %>%
filter(speaker %in% tier.equiv.temp$your.spkr) %>%
mutate(speaker2 = speaker)
for (row in 1:nrow(tier.equiv.temp)) {
if (tier.equiv.temp$gs.spkr[row] != tier.equiv.temp$your.spkr[row]) {
toChange <- which(nw.file.temp$speaker2 ==
tier.equiv.temp$your.spkr[row])
nw.file.temp$speaker[toChange] <- tier.equiv.temp$gs.spkr[row]
nw.file.temp$tier[toChange] <- gsub(tier.equiv.temp$your.spkr[row],
tier.equiv.temp$gs.spkr[row], nw.file.temp$tier[toChange])
}
}
nw.file.temp$speaker2 <- NULL
# Set up table for tier comparison and error-reporting
errors.tbl.temp <- tibble()
gs.tiers.temp <- gs.file %>%
filter(stop > seg_stt & start < seg_end & (!is.na(speaker))) %>%
select(tier, speaker) %>% distinct() %>% arrange(speaker) %>%
mutate(slice_match = "", n_annots = "", sec_annots = "",
slice_match_n = 0, nsec_spch = 0)
tiertype <- gs.tiers.temp$tier[2]
tiertype
tierspkr <- tiertype
(grepl("@", tiertype))
tierspkr <- substr(tiertype, 5, 7)
gs.row <- which(gs.tiers.temp$tier == tiertype)
tier.equiv.temp$your.spkr[which(
tier.equiv.temp$gs.spkr == tierspkr)] == "<no match>"
# Fill in n_annots and sec_annots values
segA <- gs.file %>%
filter(tier == tiertype & stop > seg_stt & start < seg_end) %>%
mutate(coder = "A")
segB <- nw.file.temp %>%
filter(tier == tiertype & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
if (!(grepl("@", tiertype))) {
gs.tiers.temp$n_annots[gs.row] <-
paste("∆ = ",(nrow(segB)-nrow(segA)),
" (GS:",nrow(segA),", You:",nrow(segB),")", sep="")
gs.tiers.temp$sec_annots[gs.row] <-
paste("∆ = ",round((sum(segB$duration)/1000-sum(segA$duration)/1000),2),
" (GS:",round(sum(segA$duration)/1000,2),", You:",
round(sum(segB$duration)/1000,2),")", sep="")
}
gs.tiers.temp$nsec_spch[gs.row] <- round(sum(segA$duration)/1000,2)
annA <- gs.file
annB <- nw.file.temp
tiertype
seg_stt
seg_end
strict
slice_sz
if (grepl("@", tiertype)) {
spkr <- substr(tiertype, 5, 7)
ttyp <- substr(tiertype, 1, 3)
} else {
spkr <- tiertype
ttyp <- "ort"
}
# Use only the comparison subset of the annotations
segA <- annA %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "A")
segB <- annB %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
segAB.spch <- bind_rows(segA, segB) %>% filter(tier == spkr)
segAB.dpdt <- bind_rows(segA, segB) %>% filter(tier == tiertype)
ttyp
ABtbl <- tibble(
slice = seq(seg_stt, seg_end - slice_sz, slice_sz),
spchA = 0,
spchB = 0,
valA = "NA",
valB = "NA")
if(nrow(segAB.spch) > 0) {
for (row in 1:nrow(segAB.spch)) {
startannot <- ifelse(segAB.spch$start[row] < seg_stt, seg_stt,
segAB.spch$start[row])
stopannot <- ifelse(segAB.spch$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.spch$stop[row])
if (segAB.spch$coder[row] == "A") {
ABtbl$spchA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
} else {
ABtbl$spchB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
}
}
}
ttyp != "ort"
if(nrow(segAB.dpdt) > 0) {
for (row in 1:nrow(segAB.dpdt)) {
startannot <- ifelse(segAB.dpdt$start[row] < seg_stt, seg_stt,
segAB.dpdt$start[row])
stopannot <- ifelse(segAB.dpdt$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.dpdt$stop[row])
valannot <- segAB.dpdt$code[row]
if (segAB.dpdt$coder[row] == "A") {
ABtbl$valA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
} else {
ABtbl$valB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
}
}
}
strict == 1
ABtbl <- ABtbl %>%
filter(spchA == 1 & spchB == 1)
ttyp == "xds"
ttyp == "vcm"
vcm.loose.matches <- tibble(
GS = c('N', 'N', 'C', 'C', 'L', 'L', 'Y', 'Y', 'U'),
NW = c('N', 'C', 'C', 'N', 'L', 'Y', 'Y', 'L', 'U')
)
vcm.loose.matches
ABtbl$match <- ifelse(paste0(ABtbl$valA, ABtbl$valA) %in%
paste0(vcm.loose.matches$GS, vcm.loose.matches$NW), 1, 0)
View(ABtbl)
ABtbl <- filter(ABtbl, valA != 'U') %>%
mutate(tier = tiertype) %>%
select(-spchA, -spchB)
comparison.tbl <- intersect.tiers(gs.file, nw.file.temp,
tiertype, seg_stt, seg_end, strict, slice_sz)
comparison.tbl
strict
intersect.tiers <- function(annA, annB, tiertype,
seg_stt, seg_end, strict, slice_sz) {
if (grepl("@", tiertype)) {
spkr <- substr(tiertype, 5, 7)
ttyp <- substr(tiertype, 1, 3)
} else {
spkr <- tiertype
ttyp <- "ort"
}
# Use only the comparison subset of the annotations
segA <- annA %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "A")
segB <- annB %>%
filter(speaker == spkr & stop > seg_stt & start < seg_end) %>%
mutate(coder = "B")
segAB.spch <- bind_rows(segA, segB) %>% filter(tier == spkr)
segAB.dpdt <- bind_rows(segA, segB) %>% filter(tier == tiertype)
# Set up comparison table
if (ttyp == "ort") {
ABtbl <- tibble(
slice = seq(seg_stt, seg_end - slice_sz, slice_sz),
spchA = 0,
spchB = 0)
} else {
ABtbl <- tibble(
slice = seq(seg_stt, seg_end - slice_sz, slice_sz),
spchA = 0,
spchB = 0,
valA = "NA",
valB = "NA")
}
# Fill in speech-on/off values for each tier
if(nrow(segAB.spch) > 0) {
for (row in 1:nrow(segAB.spch)) {
startannot <- ifelse(segAB.spch$start[row] < seg_stt, seg_stt,
segAB.spch$start[row])
stopannot <- ifelse(segAB.spch$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.spch$stop[row])
if (segAB.spch$coder[row] == "A") {
ABtbl$spchA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
} else {
ABtbl$spchB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- 1
}
}
}
# For non-orth tiers, fill in annotation values for each tier, then
# only take the intersection of speech == 1 for both A and B
if (ttyp != "ort") {
if(nrow(segAB.dpdt) > 0) {
for (row in 1:nrow(segAB.dpdt)) {
startannot <- ifelse(segAB.dpdt$start[row] < seg_stt, seg_stt,
segAB.dpdt$start[row])
stopannot <- ifelse(segAB.dpdt$stop[row] > (seg_end - slice_sz),
(seg_end - slice_sz),
segAB.dpdt$stop[row])
valannot <- segAB.dpdt$code[row]
if (segAB.dpdt$coder[row] == "A") {
ABtbl$valA[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
} else {
ABtbl$valB[max(which(ABtbl$slice <= startannot)):
(min(which(ABtbl$slice >= stopannot)))] <- valannot
}
}
}
if (strict == 1) {
ABtbl <- ABtbl %>%
filter(spchA == 1 & spchB == 1) %>%
mutate(match = as.numeric(valA == valB), tier = tiertype) %>%
select(-spchA, -spchB)
} else {
ABtbl <- ABtbl %>%
filter(spchA == 1 & spchB == 1)
if (ttyp == "xds") {
xds.loose.matches <- tibble(
GS = c('C', 'C', 'B', 'B', 'B', 'A', 'A', 'P', 'P', 'P', 'O', 'O', 'O', 'U', 'O', 'U'),
NW = c('C', 'B', 'B', 'C', 'A', 'A', 'B', 'P', 'O', 'U', 'O', 'P', 'U', 'P', 'O', 'U')
)
ABtbl$match <- ifelse(paste0(ABtbl$valA, ABtbl$valA) %in%
paste0(xds.loose.matches$GS, xds.loose.matches$NW), 1, 0)
ABtbl <- filter(ABtbl, valA != 'U') %>%
mutate(tier = tiertype) %>%
select(-spchA, -spchB)
} else if (ttyp == "vcm") {
vcm.loose.matches <- tibble(
GS = c('N', 'N', 'C', 'C', 'L', 'L', 'Y', 'Y', 'U'),
NW = c('N', 'C', 'C', 'N', 'L', 'Y', 'Y', 'L', 'U')
)
ABtbl$match <- ifelse(paste0(ABtbl$valA, ABtbl$valA) %in%
paste0(vcm.loose.matches$GS, vcm.loose.matches$NW), 1, 0)
ABtbl <- filter(ABtbl, valA != 'U') %>%
mutate(tier = tiertype) %>%
select(-spchA, -spchB)
} else {
ABtbl <- ABtbl %>%
filter(spchA == 1 & spchB == 1) %>%
mutate(match = as.numeric(valA == valB), tier = tiertype) %>%
select(-spchA, -spchB)
}
}
} else {
ABtbl <- ABtbl %>%
rename(valA = spchA, valB = spchB) %>%
mutate(match = as.numeric(valA == valB), tier = tiertype)
}
return(ABtbl)
}
comparison.tbl <- intersect.tiers(gs.file, nw.file.temp,
tiertype, seg_stt, seg_end, strict, slice_sz)
comparison.tbl
mean(comparison.tbl$match)
shiny::runApp()
runApp()
